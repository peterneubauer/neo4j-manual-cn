[[examples-user-roles-in-graphs]]
User roles in graphs
====================

This is an example showing a hierarchy of 
roles. 
What's interesting is that a tree is not sufficient for storing this structure,
as elaborated below.

image::roles.png[scaledwidth="100%"]

This is an implementation of an example found in the article 
http://www.codeproject.com/Articles/22824/A-Model-to-Represent-Directed-Acyclic-Graphs-DAG-o[A Model to Represent Directed Acyclic Graphs (DAG) on SQL Databases] 
by http://www.codeproject.com/script/Articles/MemberArticles.aspx?amid=274518[Kemal Erdogan].
The article discusses how to store http://en.wikipedia.org/wiki/Directed_acyclic_graph[
directed acyclic graphs] (DAGs) 
in SQL based DBs. DAGs are almost trees, but with a twist: it may be possible to reach 
the same node through different paths. Trees are restricted from this possibility, which 
makes them much easier to handle. In our case it is "Ali" and "Engin", 
as they are both admins and users and thus reachable through these group nodes.
Reality often looks this way and can't be captured by tree structures.

In the article an SQL Stored Procedure solution is provided. The main idea, 
that also have some support from scientists, is to pre-calculate all possible (transitive) paths. 
Pros and cons of this approach:

* decent performance on read
* low performance on insert
* wastes _lots_ of space
* relies on stored procedures

In Neo4j storing the roles is trivial. In this case we use +PART_OF+ (green edges) relationships 
to model the group hierarchy and +MEMBER_OF+ (blue edges) to model membership in groups. 
We also connect the top level groups to the reference node by +ROOT+ relationships. 
This gives us a useful partitioning of the graph. Neo4j has no predefined relationship 
types, you are free to create any relationship types and give them any semantics you want.

Lets now have a look at how to retrieve information from the graph. The Java code is using
the Neo4j Traversal API (see <<tutorial-traversal-java-api>>), the queries are done using <<cypher-query-lang, Cypher>>.

== Get the admins ==

[snippet,java]
----
component=neo4j-examples
source=org/neo4j/examples/RolesTest.java
classifier=test-sources
tag=get-admins
----

resulting in the output

[source]
----
Found: Ali at depth: 0
Found: HelpDesk at depth: 0
Found: Engin at depth: 1
Found: Demet at depth: 1

----

The result is collected from the traverser using this code:

[snippet,java]
----
component=neo4j-examples
source=org/neo4j/examples/RolesTest.java
classifier=test-sources
tag=read-traverser
----

In Cypher, a similar query would be:

[source,cypher]
----
START admins=node(14)
MATCH admins<-[:PART_OF*0..]-group<-[:MEMBER_OF]-user
RETURN user.name, group.name
----

resulting in:

[queryresult]
----
+------------------------+
| user.name | group.name |
+------------------------+
| "Ali"     | "Admins"   |
| "Engin"   | "HelpDesk" |
| "Demet"   | "HelpDesk" |
+------------------------+
3 rows
4 ms

----

== Get the group memberships of a user ==

Using the Neo4j Java Traversal API, this query looks like:

[snippet,java]
----
component=neo4j-examples
source=org/neo4j/examples/RolesTest.java
classifier=test-sources
tag=get-user-memberships
----

resuling in: 

[source]
----
Found: ABCTechnicians at depth: 0
Found: Technicians at depth: 1
Found: Users at depth: 2

----

In Cypher:

[source,cypher]
----
START jale=node(10)
MATCH jale-[:MEMBER_OF]->()-[:PART_OF*0..]->group
RETURN group.name
----

[queryresult]
----
+------------------+
| group.name       |
+------------------+
| "ABCTechnicians" |
| "Technicians"    |
| "Users"          |
+------------------+
3 rows
2 ms

----

== Get all groups ==

In Java: 

[snippet,java]
----
component=neo4j-examples
source=org/neo4j/examples/RolesTest.java
classifier=test-sources
tag=get-groups
----

resulting in:

[source]
----
Found: Admins at depth: 0
Found: Users at depth: 0
Found: HelpDesk at depth: 1
Found: Managers at depth: 1
Found: Technicians at depth: 1
Found: ABCTechnicians at depth: 2

----

In Cypher:

[source,cypher]
----
START refNode=node(16)
MATCH refNode<-[:ROOT]->()<-[:PART_OF*0..]-group
RETURN group.name
----

[queryresult]
----
+------------------+
| group.name       |
+------------------+
| "Admins"         |
| "HelpDesk"       |
| "Users"          |
| "Managers"       |
| "Technicians"    |
| "ABCTechnicians" |
+------------------+
6 rows
2 ms

----

== Get all members of all groups ==

Now, let's try to find all users in the system being part of any group.

in Java:

[snippet,java]
----
component=neo4j-examples
source=org/neo4j/examples/RolesTest.java
classifier=test-sources
tag=get-members
----

[source]
----
Found: Ali at depth: 1
Found: Engin at depth: 1
Found: Burcu at depth: 1
Found: Can at depth: 1
Found: Demet at depth: 2
Found: Gul at depth: 2
Found: Fuat at depth: 2
Found: Hakan at depth: 2
Found: Irmak at depth: 2
Found: Jale at depth: 3

----

In Cypher, this looks like:

[source,cypher]
----
START refNode=node(16)
MATCH refNode<-[:ROOT]->root, p=root<-[PART_OF*0..]-()<-[:MEMBER_OF]-user
RETURN user.name, min(length(p))
ORDER BY min(length(p)), user.name
----

and results in the following output:

[queryresult]
----
+----------------------------+
| user.name | min(length(p)) |
+----------------------------+
| "Ali"     | 1              |
| "Burcu"   | 1              |
| "Can"     | 1              |
| "Engin"   | 1              |
| "Demet"   | 2              |
| "Fuat"    | 2              |
| "Gul"     | 2              |
| "Hakan"   | 2              |
| "Irmak"   | 2              |
| "Jale"    | 3              |
+----------------------------+
10 rows
44 ms

----

As seen above, querying even more complex scenarios can be done using comparatively short
constructs in Java and other query mechanisms.


